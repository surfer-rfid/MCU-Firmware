//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// Module : RFIDr Firmware TX Radio RAM loading                                 //
//                                                                              //
// Filename: rfidr_txradio.c                                                    //
// Creation Date: circa 10/31/2016                                              //
// Author: Edward Keehr                                                         //
//                                                                              //
//    Copyright 2021 Superlative Semiconductor LLC                              //
//                                                                              //
//    Licensed under the Apache License, Version 2.0 (the "License");           //
//    you may not use this file except in compliance with the License.          //
//    You may obtain a copy of the License at                                   //
//                                                                              //
//       http://www.apache.org/licenses/LICENSE-2.0                             //
//                                                                              //
//    Unless required by applicable law or agreed to in writing, software       //
//    distributed under the License is distributed on an "AS IS" BASIS,         //
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  //
//    See the License for the specific language governing permissions and       //
//    limitations under the License.                                            //
//                                                                              //
// Description:                                                                 //
//                                                                              //
//    This file contains code required for loading the TX RAM on the RFIDr      //
//    FPGA. This file also contains code related to EPCs to be transmitted.     //
//                                                                              //
//    Revisions:                                                                //
//    061619 - Major commentary cleanup.                                        //
//    121219 - Clean up for open sourcing. Add in kill functionality. Add in    //
//    improved write and select functions for more flexible use.                //
//                                                                              //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

#include "app_error.h"
#include "app_util_platform.h"
#include "nordic_common.h"
#include "ble_rfidrs.h"
#include "nrf_error.h"
#include "rfidr_error.h"
#include "rfidr_spi.h"
#include "rfidr_txradio.h"
#include <ctype.h>
#include <math.h>
#include <string.h>

//TX RAM addresses. These are the sections of TX RAM where the data for each of the given commands is stored.
//If the commands are required to change during an RFID transaction, the firmware must intervene and update the TX RAM
//with a new sequence of opcodes for said command.

#define    TX_RAM_ADDR_OFFSET_TXCW0        0    //These offsets are in number of 16-address (16-byte) chunks
#define    TX_RAM_ADDR_OFFSET_QUERY        1
#define    TX_RAM_ADDR_OFFSET_QRY_REP      2
#define    TX_RAM_ADDR_OFFSET_ACK_RN16     3
#define    TX_RAM_ADDR_OFFSET_ACK_HDL      4
#define    TX_RAM_ADDR_OFFSET_NAK          5
#define    TX_RAM_ADDR_OFFSET_REQHDL       6
#define    TX_RAM_ADDR_OFFSET_REQRN16      7
#define    TX_RAM_ADDR_OFFSET_LOCK         8
#define    TX_RAM_ADDR_OFFSET_READ         10
#define    TX_RAM_ADDR_OFFSET_WRITE0       13    //We allot 24 bytes per write. It takes 6 writes to write a 96b EPC. We allot 6 writes in memory, requiring 144 bytes
#define    TX_RAM_ADDR_OFFSET_SELECT       22    //There are 160 bytes left. We may use up to 73 bytes per select command if we use a 16b EBV and 96b condition field.
#define    TX_RAM_ADDR_OFFSET_SEL_2        27    //Therefore, we must allot 80 addresses for each select packet under this current addressing scheme.

//TX GEN opcodes. Each of these codes is a 4-bit value. Together, they can be used to build the mandatory command waveforms for RFID EPC GEN 2 specification.
//Most opcodes represent a high-low signal with a given high-time and a given low-time to realize the ASK-DSB TX waveform.
//The high-low signals are generated by a counter with specific high-count and low-count values for the FPGA TX GEN clock, which runs at 4.5MHz.

#define    TXCW0            0    //Hi count: 8190, Lo count: 0 - Transmit continuous wave for 1.8ms. Use this for extra time to promote TX cancellation convergence.
#define    BEGIN_SELECT     1    //Hi count: 8190, Lo count: 56 - Prior to select command, transmit CW for 1.8ms then nothing for 12.5us (the preamble delimiter).
#define    BEGIN_REGULAR    2    //Hi count: 576, Lo count: 56 - Prior to query, lock, write, read commands, transmit CW for 128us (min. intercommand spacing) then a delimiter.
#define    DUMMY_ZERO       3    //Hi count: 54, Lo count: 42 - Output a zero but do not have it counted as a data zero by the TX GEN state machine (used for preamble zero).
#define    SINGLE_ZERO      4    //Hi count: 54, Lo count: 42 - Output a single normal data-0 symbol. Counted as data by CRC generator.
#define    SINGLE_ONE       5    //Hi count: 126, Lo count: 42 - Output a single normal data-1 symbol. Counted as data by CRC generator.
#define    RTCAL            6    //Hi count: 222, Lo count: 42 - Output an RTCAL symbol for the command preamble.
#define    TRCAL            7    //Hi count: 468, Lo count: 42 - Output a TRCAL symbol for the command preamble.
#define    NAK_END          8    //Follow a NAK packet with CW high for 576 counts so we don't get a CW-high short blip as the PA shuts down.
#define    XOR_NEXT_16B     9    //Tell the TX GEN state machine to XOR the next 16 data bits that come through with the register-stored RN16 data.
#define    INSERT_CRC16     10   //Insert CRC16 into outgoing command. Typically used at the very end of a command.
#define    INSERT_RN16      11   //Insert last RX'ed RN16 into outgoing command.
#define    INSERT_HANDLE    12   //Insert last RX'ed handle into outgoing command.
#define    LAST_WRITE       13   //Inform TX GEN state machine that the present command is the last write.
#define    END_PACKET       14   //Exit the TX GEN state machine and return control back to the FPGA RADIO FSM.
#define    BEGIN_IMMED      15   //Hi count: 222, Lo count: 56 - Begin within one RTCAL time for time-critical response commands like ACK, NAK, QUERY_REP, QUERY_ADJ.

//State variables involved in TX waveform generation which we wish to keep restricted to the scope of this file.
static    rfidr_select_raw_t       m_select_raw;                        //Structure which holds the values in a select command exclusive of the EPC.
static    rfidr_query_raw_t        m_query_raw;                         //Structure which holds the values in a query command exclusive of the 5 CRC bits.
static    rfidr_query_session_t    m_query_rep_session;                 //Retain session information in between calls to the state machine.
static    uint8_t    m_app_specd_target_epc[MAX_EPC_LENGTH_IN_BYTES];   //Holds EPC for iDevice-specified targeted search. Assume MSB is the one with lowest index.
static    uint8_t    m_app_specd_program_epc[MAX_EPC_LENGTH_IN_BYTES];  //Holds EPC for iDevice-specified targeted programming. Assume MSB is the one with lowest index.
static    uint8_t    m_last_inv_epc[MAX_EPC_LENGTH_IN_BYTES];           //Holds EPC for last tag found via inventory. Assume MSB is the one with lowest index.
static    uint8_t    m_zero_epc[MAX_EPC_LENGTH_IN_BYTES];               //Holds an all-zero EPC. Assume MSB is the one with lowest index.
static    uint8_t    m_dummytag_epc[MAX_EPC_LENGTH_IN_BYTES];           //Holds EPC for the dummy tags used for phase calibration for ranging. Assume MSB is the one with lowest index.
static    uint8_t    m_fmw_specd_target_epc[MAX_EPC_LENGTH_IN_BYTES];   //Holds a variable EPC that is set internally by the software, in another function.
static    uint8_t    m_kill_passwd[4];                                  //Holds the kill password. For now we just define a random set of bytes for this. In future, it can be sent in through the app.
static    uint8_t    m_length_app_specd_target_epc;                     //We need to hold the length of the app specd target EPC as a state variable.
static    uint8_t    m_length_fmw_specd_target_epc;                     //We need to hold the length of the software specd target EPC as a state variable.

uint32_t     rfidr_txradio_init(void)
{
    //Initialize the state variables used with this file with default values so that a major error does not occur if
    //the reader is used without any further configuration.

    uint32_t   err_code   = NRF_SUCCESS;
    int32_t    loop_i     = 0;

    rfidr_select_raw_t    select_raw_init;
    rfidr_query_raw_t     query_raw_init;

    memset(&select_raw_init, 0, sizeof(select_raw_init));
    memset(&query_raw_init, 0, sizeof(query_raw_init));

    //Set the target and new EPC state variables to all zeros.
    for(loop_i=0;loop_i<MAX_EPC_LENGTH_IN_BYTES;loop_i++)
    {
        m_app_specd_target_epc[loop_i]        =    0;
        m_fmw_specd_target_epc[loop_i]        =    0;
        m_app_specd_program_epc[loop_i]       =    0;
        m_zero_epc[loop_i]                    =    0;
        m_last_inv_epc[loop_i]                =    0;
    }

    m_length_app_specd_target_epc=MAX_EPC_LENGTH_IN_BYTES;
    m_length_fmw_specd_target_epc=MAX_EPC_LENGTH_IN_BYTES;

    //Set the "dummytag" EPC to a set of bytes that correspond to the MSB of the dummy tags used for phase calibration of the 2018 reader variants
    //As of 110520 these bits are correct.

    #if 0
    m_dummytag_epc[0]    =  0x30;
    m_dummytag_epc[1]    =  0x05;
    m_dummytag_epc[2]    =  0xfb;
    m_dummytag_epc[3]    =  0x63;
    m_dummytag_epc[4]    =  0xac;
    m_dummytag_epc[5]    =  0x1f;
    m_dummytag_epc[6]    =  0x36;
    m_dummytag_epc[7]    =  0x81;
    m_dummytag_epc[8]    =  0xec;
    m_dummytag_epc[9]    =  0x88;
    m_dummytag_epc[10]   =  0x04;
    m_dummytag_epc[11]   =  0x68;
    #endif
    
    m_dummytag_epc[0]    =  0x01;
    m_dummytag_epc[1]    =  0x23;
    m_dummytag_epc[2]    =  0x45;
    m_dummytag_epc[3]    =  0x67;
    m_dummytag_epc[4]    =  0x89;
    m_dummytag_epc[5]    =  0xab;
    m_dummytag_epc[6]    =  0xcd;
    m_dummytag_epc[7]    =  0xef;
    m_dummytag_epc[8]    =  0x89;
    m_dummytag_epc[9]    =  0xab;
    m_dummytag_epc[10]   =  0xcd;
    m_dummytag_epc[11]   =  0x16;

    //Below is supposed to be leetspeak for 'kill a tag' :/
    m_kill_passwd[0]     =  0x41;
    m_kill_passwd[1]     =  0x77;
    m_kill_passwd[2]     =  0xa8;
    m_kill_passwd[3]     =  0xa6;

    //Default values for the Select command
    select_raw_init.command   = 10;            //4 bit value
    select_raw_init.target    = TARGET_S2;    //3 bit value
    select_raw_init.action    = ACTION_A0;    //3 bit value
    select_raw_init.membank   = 1;            //2 bit value, select epc mem bank only
    select_raw_init.pointer   = 32;            //8 bit value - EPC memory starts at 0x20 (32) in the EPC Mem back (Sec 6.3.2.1.2)
    //select_raw_init.length  = 96;        //Was deprecated on 12/3/2019

    //Default values for the Query command
    query_raw_init.command    = 8;            //4 bit value
    query_raw_init.dr         = 1;            //1 bit - Select DR=64/3
    query_raw_init.mod_index  = 3;            //2 bit - Select M=8
    query_raw_init.trext      = 1;            //1 bit - use pilot tone
    query_raw_init.sel        = SEL_PSL;        //2 bit - Select tags with selected bit set
    query_raw_init.session    = SESSION_S2;    //2 bit - Use S2 session for longer turn off duration
    query_raw_init.target     = TARGET_A;        //1 bit - Tags choose flag A when they power up.

    m_select_raw              = select_raw_init;
    m_query_raw               = query_raw_init;

    m_query_rep_session       = SESSION_S2;

    return err_code;

}

//Copy the target EPC coming in from the BTLE characteristic write to the state variable.
//Also copy the EPC length, which hopefully came from the app. Sanitize length again using MAX_EPC_LENGTH_IN_BYTES.
//Set remaining bytes in the buffer to 0 so that leftover garbage is overwritten.

rfidr_error_t    set_app_specd_target_epc(ble_rfidrs_t * p_rfidrs, const uint8_t * p_app_specd_target_epc, uint8_t sanitized_length)
{
    uint8_t loop_i=0;

    m_length_app_specd_target_epc=MIN(MAX_EPC_LENGTH_IN_BYTES,sanitized_length);

    for(loop_i=0;loop_i<MAX_EPC_LENGTH_IN_BYTES;loop_i++)
    {
        if(loop_i<m_length_app_specd_target_epc)
            m_app_specd_target_epc[loop_i]    =    p_app_specd_target_epc[loop_i];
        else
            m_app_specd_target_epc[loop_i]    =    0;
    }

    //Send the sanitized epc back to the reader.
    ble_rfidrs_target_epc_send(p_rfidrs,m_app_specd_target_epc,(uint16_t)m_length_app_specd_target_epc);

    return     RFIDR_SUCCESS;
}

//This function sets the state variables for the software-specified target epc
//This function allows us to call the function with an arbitrary string as an EPC in the software, then use this EPC for various purposes.
//This function figures out what the length of the software-specified target EPC is also.

rfidr_error_t set_fmw_specd_target_epc(char * epc)
{
    uint8_t            loop_i            =    0;
    uint8_t            temp_byte         =    0;
    uint8_t            temp_2x_length    =    0;
    rfidr_error_t      error_code        =    RFIDR_SUCCESS;

    //First, we overwrite the buffer to all zeros to clear out anything that was there before

    for (loop_i=0; loop_i <MAX_EPC_LENGTH_IN_BYTES; loop_i++) //Go through the input string and convert it into a valid byte-wise EPC. The loop length enforces EPC size.
    {
        m_fmw_specd_target_epc[loop_i] = 0;
    }

    for (loop_i=0; loop_i <2*MAX_EPC_LENGTH_IN_BYTES; loop_i++) //Go through the input string and convert it into a valid byte-wise EPC. The loop length enforces EPC size.
    {
        if(epc[loop_i]==0){break;} //If we hit the end of the string early, we're done adding to the EPC. If first char is a null, exit and say length is zero.

        temp_2x_length++; //We got something that we'll add to the EPC, so let's increment the length.

        if(isalpha(epc[loop_i]))    //If the character is a letter
            temp_byte    =    ((uint8_t)toupper(epc[loop_i])+10-'A') & 15;
            //Then convert it to an uppercase letter, cast it to uint8_t, then convert to equivalent hex value. Mask with a nibble (15).
        else if(isdigit(epc[loop_i]))    //If the character is a digit
            temp_byte    =    (epc[loop_i]-'0') & 15;    //Then convert the digital to its equivalent hex value. Mask with a nibble (15).
        else
            temp_byte    =    0;    //If we get something weird, sanitize it to a 0.

        if((loop_i % 2) == 0)    //Assuming we are on the first nibble of a byte
            m_fmw_specd_target_epc[loop_i >> 1] = temp_byte << 4;    //Push that nibble into the MSB of the byte and set the LSB to zero.
        else    //If we are on the second nibble of a byte
            m_fmw_specd_target_epc[loop_i >> 1] |= temp_byte << 0; //Push the current nibble into the LSB of the byte
    }

    m_length_fmw_specd_target_epc = ((temp_2x_length+1) >> 1); 
    //How far we've counted before we got to the end of the loop is how long the EPC is. Round up, obviously.

    return error_code;

}

//Copy the new EPC coming in from the BTLE characteristic write to the state variable.
//We assume this always has a length of MAX_EPC_LENGTH_IN_BYTES.

rfidr_error_t    set_app_specd_program_epc(ble_rfidrs_t * p_rfidrs, const uint8_t * p_app_specd_program_epc)
{
    uint8_t loop_i=0;

    for(loop_i=0;loop_i<MAX_EPC_LENGTH_IN_BYTES;loop_i++)
    {
        m_app_specd_program_epc[loop_i] = p_app_specd_program_epc[loop_i];
    }

    //Send the sanitized epc back to the reader.
    ble_rfidrs_program_epc_send(p_rfidrs,m_app_specd_program_epc,(uint16_t)MAX_EPC_LENGTH_IN_BYTES);
    return    RFIDR_SUCCESS;
}

//Copy the new EPC coming in from the inventory routine to the state variable.
//We assume this always has a length of MAX_EPC_LENGTH_IN_BYTES.

rfidr_error_t    set_last_inv_epc(const uint8_t * p_last_inv_epc)
{
    int loop_i=0;

    for(loop_i=0;loop_i<MAX_EPC_LENGTH_IN_BYTES;loop_i++)
    {
        m_last_inv_epc[loop_i] = p_last_inv_epc[loop_i];
    }
    return    RFIDR_SUCCESS;
}

//Read back the target EPC state variable to the iDevice over BTLE for checking.

rfidr_error_t    read_app_specd_target_epc(uint8_t * p_app_specd_target_epc)
{
    int loop_i=0;

    for(loop_i=0;loop_i<m_length_app_specd_target_epc;loop_i++)
    {
        p_app_specd_target_epc[loop_i] = m_app_specd_target_epc[loop_i];
    }
    return     RFIDR_SUCCESS;
}

//Read just the app-specified target EPC state variable length.

rfidr_error_t    read_length_app_specd_target_epc(uint8_t * p_length_app_specd_target_epc)
{
    *p_length_app_specd_target_epc = m_length_app_specd_target_epc;
    return     RFIDR_SUCCESS;
}

//Read just the software-specified EPC state variable length.

rfidr_error_t    read_length_fmw_specd_target_epc(uint8_t * p_length_fmw_specd_target_epc)
{
    *p_length_fmw_specd_target_epc = m_length_fmw_specd_target_epc;
    return     RFIDR_SUCCESS;
}

//Read back the application-specified EPC state variable to the iDevice over BTLE for checking.
//We assume this always has a length of MAX_EPC_LENGTH_IN_BYTES.

rfidr_error_t    read_app_specd_program_epc(uint8_t * p_app_specd_program_epc)
{
    int loop_i=0;

    for(loop_i=0;loop_i<MAX_EPC_LENGTH_IN_BYTES;loop_i++)
    {
        p_app_specd_program_epc[loop_i] = m_app_specd_program_epc[loop_i];
    }
    return    RFIDR_SUCCESS;
}

//Read back the last inventoried EPC state variable to the iDevice over BTLE for checking.
//We assume this always has a length of MAX_EPC_LENGTH_IN_BYTES.

rfidr_error_t    read_last_inv_epc(uint8_t * p_last_inv_epc)
{
    int loop_i=0;

    for(loop_i=0;loop_i<MAX_EPC_LENGTH_IN_BYTES;loop_i++)
    {
        p_last_inv_epc[loop_i] = m_last_inv_epc[loop_i];
    }
    return    RFIDR_SUCCESS;
}

//Set whether the contents of the select command target one of the 4 session flags or the select flag.
rfidr_error_t    set_select_target(rfidr_select_target_t target)
{
    m_select_raw.target    = target;
    return    RFIDR_SUCCESS;
}

//Set the action specified by the select command (the 8 actions are specified in more detail in the EPC GEN 2 specification).
rfidr_error_t    set_select_action(rfidr_select_action_t action)
{
    m_select_raw.action    = action;
    return    RFIDR_SUCCESS;
}

//In the query command, there is the option to select all tags, only tags with the select flag active, or only tags with the select flag inactive.
rfidr_error_t    set_query_sel(rfidr_query_sel_t sel)
{
    m_query_raw.sel    = sel;
    return    RFIDR_SUCCESS;
}

//Set the query command session.
rfidr_error_t    set_query_session(rfidr_query_session_t session)
{
    m_query_raw.session    = session;
    m_query_rep_session    = session;
    return    RFIDR_SUCCESS;
}

//Set the query command target: tags with their inventory flag set to "A" or "B"
rfidr_error_t    set_query_target(rfidr_query_target_t target)
{
    m_query_raw.target    = target;
    return    RFIDR_SUCCESS;
}

//Set the query command "Q" value.
rfidr_error_t    set_query_q(uint8_t query_q)
{
    m_query_raw.query_q    = query_q;
    return    RFIDR_SUCCESS;
}

//Merge the opcode nibbles into a single byte to be transmitted over SPI to a given TX RAM (which is organized by byte) address.
static uint8_t merge_code_nibbles(uint8_t codeMSB, uint8_t codeLSB)
{
    uint8_t    msb_mask        =    240;
    uint8_t    lsb_mask        =    15;

    return ((codeMSB << 4) & msb_mask) | (codeLSB & lsb_mask);
}

//Combine merge_code_nibbles and the spi_cntrlr_tx_robust function since we use them together all the time.

static rfidr_error_t merge_and_write_tx_ram(uint8_t codeMSB, uint8_t codeLSB, uint16_t radio_sram_addr)
{
    uint8_t            radio_sram_wdata      =    0;        //The byte data to be written to the FPGA radio SRAM.
    rfidr_error_t      error_code            =    RFIDR_SUCCESS;
    
    radio_sram_wdata    =    merge_code_nibbles(codeMSB,codeLSB);
    error_code          =    spi_cntrlr_write_tx_robust(RFIDR_RDIO_MEM,RFIDR_SPI_TXRAM,radio_sram_addr,radio_sram_wdata);
    if(error_code != RFIDR_SUCCESS){return error_code;}

    return RFIDR_SUCCESS;
}

//Bitwise-construct a select packet with an EPC and load it into the 'select' section of the TX RAM.
//This function can load into either of the two select packet addresses in the FPGA and
//draws from many different EPC sources.

//061020 - Now that we are accepting EPCs with less than MAX_EPC_LENGTH_IN_BYTES through the app and software,
//we need to ensure that we don't load such EPCs to the select packet during search and program.
//We'll leave that to the functions in rfidr_state.c to ensure when this function is called,
//the epc_length_in_bytes argument is set to MAX_EPC_LENGTH_IN_BYTES

rfidr_error_t load_select_packet_only(rfidr_select_epc_type_t epc_type, uint8_t epc_length_in_bytes, rfidr_select_packet_type_t packet_type)
{
    uint8_t         temp_epc[MAX_EPC_LENGTH_IN_BYTES];    //We'll use this to store the pointer to the array to be utilized.
    uint32_t        select_vector_begin    =    0;        //This variable stores the beginning of the select packet, prior to the EPC and truncation-bit.
    uint64_t        select_vector[2]       =    {0};      //This variable stores the complete select packet, including the EPC but not the truncation-bit.
    uint8_t         loop_sram              =    0;        //A loop variable.
    uint16_t        radio_sram_addr        =    0;        //The address in the FPGA radio SRAM to which data will be written.
    uint8_t         index_msb              =    0;        //A variable to hold the select vector index to be used when extracting bit-wise data from the select vector.
    uint8_t         shift_msb              =    0;        //A variable to index the select vector to extract the bit-wise data from the vector.
    uint8_t         index_lsb              =    0;        //A variable to hold the select vector index to be used when extracting bit-wise data from the select vector.
    uint8_t         shift_lsb              =    0;        //A variable to index the select vector to extract the bit-wise data from the vector.
    uint8_t         loop_load              =    0;
    rfidr_error_t   error_code             =    RFIDR_SUCCESS;

    //Select which EPC source to be utilized
    for(loop_load=0; loop_load<epc_length_in_bytes; loop_load++)
    {
        switch(epc_type)
        {
            case    APP_SPECD_EPC:    temp_epc[loop_load] = m_app_specd_target_epc[loop_load];    break;
            case    FMW_SPECD_EPC:    temp_epc[loop_load] = m_fmw_specd_target_epc[loop_load];    break;
            case    LAST_INV_EPC:     temp_epc[loop_load] = m_last_inv_epc[loop_load];            break;
            case    DUMMYTAG_EPC:     temp_epc[loop_load] = m_dummytag_epc[loop_load];            break;
            case    ZERO_EPC:         temp_epc[loop_load] = m_zero_epc[loop_load];                break;
            default: temp_epc[loop_load] = m_zero_epc[loop_load];                                 break;
        }
    }

    //Convert the select_raw struct into a 28-bit bit string

    //4-bit command
    select_vector_begin |= ((m_select_raw.command & 15) << 24);

    //3 bit target
    switch(m_select_raw.target)
    {
        case TARGET_S0: select_vector_begin |= (0 << 21); break;
        case TARGET_S1: select_vector_begin |= (1 << 21); break;
        case TARGET_S2: select_vector_begin |= (2 << 21); break;
        case TARGET_S3: select_vector_begin |= (3 << 21); break;
        case TARGET_SL: select_vector_begin |= (4 << 21); break;
        default:  select_vector_begin |= (4 << 21); break;
    }

    //3 bit action
    switch(m_select_raw.action)
    {
        case ACTION_A0: select_vector_begin |= (0 << 18); break;
        case ACTION_A1: select_vector_begin |= (1 << 18); break;
        case ACTION_A2: select_vector_begin |= (2 << 18); break;
        case ACTION_A3: select_vector_begin |= (3 << 18); break;
        case ACTION_A4: select_vector_begin |= (4 << 18); break;
        case ACTION_A5: select_vector_begin |= (5 << 18); break;
        case ACTION_A6: select_vector_begin |= (6 << 18); break;
        case ACTION_A7: select_vector_begin |= (7 << 18); break;
        default: select_vector_begin |= (0 << 18); break;
    }
    //2 bit membank
    select_vector_begin |= ((m_select_raw.membank & 3) << 16);

    //8 bit pointer
    select_vector_begin |= ((m_select_raw.pointer & 255) << 8);

    //8 bit length - must be the number of bits, so right shift the number of bytes by 3 (to effect a mult-by-8)
    select_vector_begin |= (((epc_length_in_bytes << 3) & 255) << 0);

    //load all data into the select vector (125 bits)
    //The strategy is to load all of the bits starting at the MSB of the first select_vector uint64_t minus the first nibble.
    //select_vector[1] will hold, from MSB to LSB, 4 zeros, the select_vector_begin, then the 4 MSB EPC bytes.
    //select_vector[0] will hold, from LSB to LSB, the 8 LSB EPC bytes.
    
    select_vector[1] |= (((uint64_t)select_vector_begin & (uint64_t)((1 << 28)-1)) << 32); //32=60-28 - have first bit of select vector begin be MSB of select vector minus the first nibble

    for(loop_sram=0; loop_sram<epc_length_in_bytes; loop_sram++)
    {
            select_vector[(loop_sram < 4) ? 1 : 0] |= ((uint64_t)temp_epc[loop_sram] & 255) << ((88-(loop_sram << 3)) % 64);     
            //Add on EPC bytes to this vector as specified length permits.
            //For 12 EPC bytes, there will be no more room for the final '0' bit. We'll add that in individually.
            //((88-(loop_sram << 3)) % 64) results in loop_sram=0->bit shift of 24, 1->16, 2->8, 3->0, 4->56, 5->48, ... 11->0
            //Note the last bit of this vector is not the zero we need to specify "no EPC truncation" as required by the select packet.
            //We will put this zero in manually later on.
    }

    //Set the radio SRAM starting address to write data to. 
    if(packet_type==SEL_PACKET_NO_2)
        radio_sram_addr     =    TX_RAM_ADDR_OFFSET_SEL_2 << 4;    //For a second select packet.
    else
        radio_sram_addr     =    TX_RAM_ADDR_OFFSET_SELECT << 4; //For the first select packet.

    //Load the opcodes into TX RAM. Convert single bits into opcodes where necessary.
    error_code    =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_SELECT,radio_sram_addr++);
        if(error_code != RFIDR_SUCCESS){return error_code;}
    //59 is the bit index of the first bit of the select_vector_begin section
    error_code    =    merge_and_write_tx_ram(((select_vector[1] >> 59) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),RTCAL,radio_sram_addr++);
        if(error_code != RFIDR_SUCCESS){return error_code;}
    

    for(loop_sram=0;loop_sram < ((7+(epc_length_in_bytes << 1)) << 1)-1;loop_sram++) //(7+2*epc_length)*2 is the number of 2-bit pairs we need to add to the tx ram. For the last of these, need to add a SINGLE_ZERO for "no epc truncation"
    {
        index_msb    =    ((121-(loop_sram<<1)) >> 6) & 1;    //For loop_sram=0, will be 1. Will remain 1 until all of the bits from select_vector[1] are sent out.
        shift_msb    =    (121-(loop_sram<<1)) % 64;            //For loop_sram=0, starts at bit 57, the third bit of the select_vector_begin section.
        index_lsb    =    ((122-(loop_sram<<1)) >> 6) & 1;    //For loop_sram=0, will be 1. Will remain 1 until all of the bits from select_vector[1] are sent out.
        shift_lsb    =    (122-(loop_sram<<1)) % 64;            //For loop_sram=0, starts at bit 58, the second bit of the select_vector_begin section.

        error_code    =    merge_and_write_tx_ram(((select_vector[index_msb] >> shift_msb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),((select_vector[index_lsb] >> shift_lsb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),radio_sram_addr++);
                if(error_code != RFIDR_SUCCESS){return error_code;}
    }
    
    //Take care of the final bit and the "no EPC truncation" zero entry required in the select packet.
    //We are counting on the last loop_sram++ in the for loop to have incremented loop_sram here so that we can get the final correct bit of the select vector.
    //This should still work if the EPC length is zero (a dummy select packet).
    
    index_lsb    =    ((122-(loop_sram<<1)) >> 6) & 1;
    shift_lsb    =    (122-(loop_sram<<1)) % 64;

    error_code    =    merge_and_write_tx_ram(SINGLE_ZERO,((select_vector[index_lsb] >> shift_lsb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),radio_sram_addr++);
        if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code    =    merge_and_write_tx_ram(END_PACKET,INSERT_CRC16,radio_sram_addr++);
        if(error_code != RFIDR_SUCCESS){return error_code;}
    
    return RFIDR_SUCCESS;
}

//Bitwise-construct a dummy select packet and load it into the 'select' section of the TX RAM.
//A dummy select packet is one with no EPC. In this fashion, we can alter the flags of the tags in the local area in preparation for Query.
//We used to use this packet for "Search" during early development.
//This function was different enough from the normal load select packet function that it was easiest to define its own function.
rfidr_error_t load_dummy_select_packet_only()
{
    rfidr_error_t    error_code    =    RFIDR_SUCCESS;

    error_code    =    load_select_packet_only(ZERO_EPC,0,SEL_PACKET_NO_1);

    return error_code;
}

//This file computes the 5-bit CRC to be appended to the Query command.
//The function has to be run during load-time of the Query section of the TX RAM.
static uint8_t compute_query_crc5(uint32_t query_vector_begin)
{
    uint8_t    state       =    9;        //This is what Sec F.1 of the RFID specification tells us to start out with
    uint8_t    state_new   =    0;
    uint8_t    mask        =    31;        //5-bit LSB mask
    uint8_t    length      =    17;        //The length of the query vector prior to adding the 5 CRC bits
    uint8_t    loop_crc    =    0;
    uint8_t    xor_bit     =    0;

    for(loop_crc=0; loop_crc<length; loop_crc++)
    {
        xor_bit       =  ((query_vector_begin >> (length-1-loop_crc)) & 1) ^ ((state >> 4) & 1);
        state_new     =  0;
        state_new    |=  (((state >> 3) & 1) << 4);
        state_new    |=  ((((state >> 2) & 1) ^ xor_bit ) << 3);
        state_new    |=  (((state >> 1) & 1) << 2);
        state_new    |=  (((state >> 0) & 1) << 1);
        state_new    |=  xor_bit;
        state         =   state_new & mask;
    }

return state;
}

//Bitwise-construct a Query command with an EPC and load it into the 'select' section of the TX RAM.
//We modify this function to also support fast writes of the query packet when all we want to do is
//flip the tag to be queried. This is the case when we want to rapidly track a single tag by
//repeated fast EPC writes. The tag-tracking feature came about through discussions with the Sample
//Group at the University of Michigan in early 2020.

rfidr_error_t load_query_packet_only(rfidr_query_flagswap_t flagswap)
{
    uint32_t         query_vector_begin    =    0;
    uint32_t         query_vector          =    0;
    uint8_t          crc5                  =    0;
    uint8_t          loop_sram             =    0;
    uint16_t         radio_sram_addr       =    0;
    uint8_t          shift_msb             =    0;
    uint8_t          shift_lsb             =    0;
    rfidr_error_t    error_code            =    RFIDR_SUCCESS;

    //Convert the query_raw struct into a 28-bit bit string

    //4-bit command
    query_vector_begin |= ((m_query_raw.command & 15) << 13);

    //1-bit dr
    query_vector_begin |= ((m_query_raw.dr & 1) << 12);

    //2-bit mod_index
    query_vector_begin |= ((m_query_raw.mod_index & 3) << 10);

    //1-bit trext
    query_vector_begin |= ((m_query_raw.trext & 1) << 9);

    //2 bit sel
    switch(m_query_raw.sel)
    {
        case SEL_ALL: query_vector_begin |= (0 << 7); break;
        case SEL_NSL: query_vector_begin |= (2 << 7); break;
        case SEL_PSL: query_vector_begin |= (3 << 7); break;
        default:  query_vector_begin |= (0 << 7); break;
    }

    //2 bit session
    switch(m_query_raw.session)
    {
        case SESSION_S0: query_vector_begin |= (0 << 5); break;
        case SESSION_S1: query_vector_begin |= (1 << 5); break;
        case SESSION_S2: query_vector_begin |= (2 << 5); break;
        case SESSION_S3: query_vector_begin |= (3 << 5); break;
        default: query_vector_begin |= (2 << 5); break;
    }

    //1 bit session
    switch(m_query_raw.target)
    {
        case TARGET_A: query_vector_begin |= (0 << 4); break;
        case TARGET_B: query_vector_begin |= (1 << 4); break;
        default: query_vector_begin |= (0 << 4); break;
    }

    //4 bit Q
    query_vector_begin |= ((m_query_raw.query_q & 15) << 0);

    //Compute the 5-bit CRC
    crc5            =    compute_query_crc5(query_vector_begin);
    //Assemble the final string of binary bits that make up the Query command.
    query_vector    =    ((query_vector_begin << 5) | (uint32_t)crc5) & (uint32_t)((1 << 22)-1);

    //Load opcodes into the TX RAM, converting binary 1's and 0's into opcodes where necessary.
    radio_sram_addr     =    TX_RAM_ADDR_OFFSET_QUERY << 4;
    if(flagswap==FLAGSWAP_NO)
    {
        error_code      =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_REGULAR,radio_sram_addr++);       if(error_code != RFIDR_SUCCESS){return error_code;}
        error_code      =    merge_and_write_tx_ram(TRCAL,RTCAL,radio_sram_addr++);                    if(error_code != RFIDR_SUCCESS){return error_code;}
    }
    else
    {
        radio_sram_addr+=2;
    }

    for(loop_sram=0;loop_sram<=10;loop_sram++)
    {
        shift_msb       =    20-(loop_sram<<1);
        shift_lsb       =    21-(loop_sram<<1);

        if(flagswap==FLAGSWAP_NO || loop_sram >= 6)    //For flagswap yes, overwrite A/B, Q, CRC5
        {
            error_code    =    merge_and_write_tx_ram(((query_vector >> shift_msb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),((query_vector >> shift_lsb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),radio_sram_addr++);
            if(error_code != RFIDR_SUCCESS){return error_code;}
        }
        else
        {
            radio_sram_addr++;
        }
    }
    
    if(flagswap==FLAGSWAP_NO)
    {
        error_code    =    merge_and_write_tx_ram(TXCW0,END_PACKET,radio_sram_addr++); if(error_code != RFIDR_SUCCESS){return error_code;}
    }

    return RFIDR_SUCCESS;
}

//Bitwise-construct a Write-16 bits command and load it into the TX RAM 
//In this case, we need to know the offset to the EPC memory to write to, which EPC to use, and if this is the last write.
//The last write bit tells the FPGA TX GEN state machine that this is the last write.
//Upon thinking about it more on 061619, letting the FPGA have control of all of the write operations is bad for both a programming
//robustness standpoint and possibly from an FPGA LE usage standpoint.
//On the other hand, the state machine may get more complicated if it has to handle LOCK, WRITE, and READ commands separately.

static rfidr_error_t load_write_packet_16b(rfidr_write_offset_t write_offset, rfidr_last_write_t is_last_write, rfidr_write_mode_t write_mode, rfidr_membank_t membank, uint8_t wordptr, uint8_t msbyte, uint8_t lsbyte)
{
    uint32_t         write_16b_vector    =    0;    //This vector holds the command information for the write_16b packet. It actually contains up to 189b of data.
    uint8_t          loop_sram           =    0;
    uint8_t          loop_byte           =    0;
    uint16_t         radio_sram_addr     =    0;
    uint8_t          shift_msb           =    0;
    uint8_t          shift_lsb           =    0;
    uint8_t          write_byte          =    0;
    rfidr_error_t    error_code          =    RFIDR_SUCCESS;

    //Build the components of a write-16b command into a 18-bit bit string
    
    if(write_mode==KILL_WRITE_MODE)
        write_16b_vector |= ((196 & 255) << 0);                     //Command 11000100
    else //write_mode should be WRITE in this case
    {
        write_16b_vector |= ((195 & 255) << 10);                    //Command 11000011
        write_16b_vector |= ((membank & 3) << 8);                   //The 4 MEMBANK values are encoded in the typedef enum for membank_t
        write_16b_vector |= (((write_offset+wordptr) & 15) << 0);   //Strictly write to the word pointer - not the word address
    }

    //We need to specify the offset of the EPC membank we are writing to. There are 6 such reasonable offsets for a 96 bit EPC.
    switch(write_offset)
    {
        case WRITE_OFFSET_0:     radio_sram_addr     =    (TX_RAM_ADDR_OFFSET_WRITE0 << 4) + (0 << 3);    break;
        case WRITE_OFFSET_1:     radio_sram_addr     =    (TX_RAM_ADDR_OFFSET_WRITE0 << 4) + (3 << 3);    break;
        case WRITE_OFFSET_2:     radio_sram_addr     =    (TX_RAM_ADDR_OFFSET_WRITE0 << 4) + (6 << 3);    break;
        case WRITE_OFFSET_3:     radio_sram_addr     =    (TX_RAM_ADDR_OFFSET_WRITE0 << 4) + (9 << 3);    break;
        case WRITE_OFFSET_4:     radio_sram_addr     =    (TX_RAM_ADDR_OFFSET_WRITE0 << 4) + (12 << 3);   break;
        case WRITE_OFFSET_5:     radio_sram_addr     =    (TX_RAM_ADDR_OFFSET_WRITE0 << 4) + (15 << 3);   break;
        default:                 radio_sram_addr     =    (TX_RAM_ADDR_OFFSET_WRITE0 << 4) + (0 << 3);    break;
    }

    //Write opcodes to TX RAM, converting binary 1's and 0's to opcodes where necessary.
    //Both the kill packet and the write packet start off in the same fashion
    
    error_code            =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_REGULAR,radio_sram_addr++); if(error_code != RFIDR_SUCCESS){return error_code;}
    
    //Next, finish writing the command bits no matter which mode we are in.

    if(write_mode==KILL_WRITE_MODE)
    {
        //Note that since the command vector is shorter for the kill packet, we must have the first bits out operate differently
        error_code            =    merge_and_write_tx_ram(((write_16b_vector >> 7) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),RTCAL,radio_sram_addr++); if(error_code != RFIDR_SUCCESS){return error_code;}
        
        for(loop_sram=0;loop_sram <3;loop_sram++)
        {
            shift_msb         =    5-(loop_sram<<1);
            shift_lsb         =    6-(loop_sram<<1);

            error_code        =    merge_and_write_tx_ram(((write_16b_vector >> shift_msb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),((write_16b_vector >> shift_lsb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),radio_sram_addr++);
            if(error_code != RFIDR_SUCCESS){return error_code;}
        }    
    } 
    else //For a regular WRITE here.
    {
        error_code            =    merge_and_write_tx_ram(((write_16b_vector >> 17) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),RTCAL,radio_sram_addr++); if(error_code != RFIDR_SUCCESS){return error_code;}
        
        for(loop_sram=0;loop_sram < 8;loop_sram++)
        {
            shift_msb         =    15-(loop_sram<<1);
            shift_lsb         =    16-(loop_sram<<1);

            error_code        =    merge_and_write_tx_ram(((write_16b_vector >> shift_msb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),((write_16b_vector >> shift_lsb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),radio_sram_addr++);
            if(error_code != RFIDR_SUCCESS){return error_code;}
        }
    }
    
    //Both a kill and a write are finished off in the same fashion, with the last bit of the control vector and the XOR_NEXT_16B.
    error_code            =    merge_and_write_tx_ram((XOR_NEXT_16B),((write_16b_vector >> 0) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),radio_sram_addr++); if(error_code != RFIDR_SUCCESS){return error_code;}
    
    //For both kill and a write, we have two bytes of payload data to transmit. 
    for(loop_byte=0;loop_byte < 2;loop_byte++)
    {
        if(loop_byte==0)
            write_byte=msbyte;
        else
            write_byte=lsbyte;
        
        for(loop_sram=0;loop_sram < 4;loop_sram++)
        {
            shift_msb        =    6-(loop_sram<<1);
            shift_lsb        =    7-(loop_sram<<1);

            error_code       =    merge_and_write_tx_ram(((write_byte >> shift_msb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),((write_byte >> shift_lsb) & 1) ? (SINGLE_ONE) : (SINGLE_ZERO),radio_sram_addr++);
            
            if(error_code != RFIDR_SUCCESS){return error_code;}
        }
    }
    
    //The endings of kill and write packets are quite a bit different, so they are coded up to be explicitly different.
    //Here we are just following the UHF RFID specification.
    
    if(write_mode==KILL_WRITE_MODE)
    {
        error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ZERO,radio_sram_addr++);                                            if(error_code != RFIDR_SUCCESS){return error_code;}
        error_code          =    merge_and_write_tx_ram(INSERT_HANDLE, SINGLE_ZERO,radio_sram_addr++);                                        if(error_code != RFIDR_SUCCESS){return error_code;}
        error_code          =    merge_and_write_tx_ram(is_last_write==LAST_WRITE_YES ? LAST_WRITE : END_PACKET, INSERT_CRC16,radio_sram_addr++);             if(error_code != RFIDR_SUCCESS){return error_code;}
    } 
    else //If write_mode is a regular write
    {
        error_code          =    merge_and_write_tx_ram(INSERT_CRC16,INSERT_HANDLE,radio_sram_addr++);                                         if(error_code != RFIDR_SUCCESS){return error_code;}
        error_code          =    merge_and_write_tx_ram(TXCW0,is_last_write==LAST_WRITE_YES ? LAST_WRITE : END_PACKET,radio_sram_addr++);    if(error_code != RFIDR_SUCCESS){return error_code;}    
    }
    return RFIDR_SUCCESS;
}

//This is the wrapper for writing the 96-bit new EPC to TX RAM.
//It is intended that only this function be exposed to other scopes in the RFIDr MCU firmware codebase.
rfidr_error_t    load_write_packet_only_program_epc(void)
{

    rfidr_error_t    error_code    =    RFIDR_SUCCESS;

    error_code=load_write_packet_16b(WRITE_OFFSET_0,LAST_WRITE_NO,WRITE_WRITE_MODE,MEMBANK_1,2,m_app_specd_program_epc[0],m_app_specd_program_epc[1]);    if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_write_packet_16b(WRITE_OFFSET_1,LAST_WRITE_NO,WRITE_WRITE_MODE,MEMBANK_1,2,m_app_specd_program_epc[2],m_app_specd_program_epc[3]);    if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_write_packet_16b(WRITE_OFFSET_2,LAST_WRITE_NO,WRITE_WRITE_MODE,MEMBANK_1,2,m_app_specd_program_epc[4],m_app_specd_program_epc[5]);    if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_write_packet_16b(WRITE_OFFSET_3,LAST_WRITE_NO,WRITE_WRITE_MODE,MEMBANK_1,2,m_app_specd_program_epc[6],m_app_specd_program_epc[7]);    if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_write_packet_16b(WRITE_OFFSET_4,LAST_WRITE_NO,WRITE_WRITE_MODE,MEMBANK_1,2,m_app_specd_program_epc[8],m_app_specd_program_epc[9]);     if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_write_packet_16b(WRITE_OFFSET_5,LAST_WRITE_YES,WRITE_WRITE_MODE,MEMBANK_1,2,m_app_specd_program_epc[10],m_app_specd_program_epc[11]);   if(error_code != RFIDR_SUCCESS){return error_code;}
    
    return RFIDR_SUCCESS;
}

//This is the wrapper for writing the full-96 bit zero EPC to TX RAM.
//It is intended that only this function be exposed to other scopes in the RFIDr MCU firmware codebase.
rfidr_error_t    load_write_packet_only_kill_password(void)
{
    rfidr_error_t    error_code    =    RFIDR_SUCCESS;

    error_code=load_write_packet_16b(WRITE_OFFSET_0,LAST_WRITE_NO,WRITE_WRITE_MODE,MEMBANK_0,0,m_kill_passwd[0],m_kill_passwd[1]);    if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_write_packet_16b(WRITE_OFFSET_1,LAST_WRITE_YES,WRITE_WRITE_MODE,MEMBANK_0,0,m_kill_passwd[2],m_kill_passwd[3]);    if(error_code != RFIDR_SUCCESS){return error_code;}
    
    return RFIDR_SUCCESS;
}

//This is the wrapper for writing the full-96 bit zero EPC to TX RAM.
//It is intended that only this function be exposed to other scopes in the RFIDr MCU firmware codebase.
//Note that the kill command uses the kill password, but is not technically writing it to tag memory.
rfidr_error_t    load_write_packet_only_kill_command(void)
{
    rfidr_error_t    error_code    =    RFIDR_SUCCESS;

    error_code=load_write_packet_16b(WRITE_OFFSET_0,LAST_WRITE_NO,KILL_WRITE_MODE,MEMBANK_0,0,m_kill_passwd[0],m_kill_passwd[1]);    if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_write_packet_16b(WRITE_OFFSET_1,LAST_WRITE_YES,KILL_WRITE_MODE,MEMBANK_0,0,m_kill_passwd[2],m_kill_passwd[3]);    if(error_code != RFIDR_SUCCESS){return error_code;}
    
    return RFIDR_SUCCESS;
}

//The TXCW0 packet is just one opcode. This opcode sends out a CW tone for 1.8ms to provide more time for the 
//TMN to converge.
static rfidr_error_t load_txcw0_packet(void)
{
    uint16_t         radio_sram_addr               =    0;
    rfidr_error_t    error_code                    =    0;

    radio_sram_addr    =    TX_RAM_ADDR_OFFSET_TXCW0 << 4;
    error_code         =    merge_and_write_tx_ram(END_PACKET,TXCW0,radio_sram_addr++); if(error_code != RFIDR_SUCCESS){return error_code;}
    
    return RFIDR_SUCCESS;
}

//Bitwise-construct a Query Rep command and load it into the TX RAM .
//In this case we need to draw upon the session state variable 
//(another good reason to make this a state variable - so that we can issue Query, Query Rep and Query Adjust TX RAM writes easily with only one setting of the session).
rfidr_error_t load_query_rep_packet(void)
{
    uint16_t         radio_sram_addr               =    0;
    rfidr_error_t    error_code                    =    0;
    uint8_t          session_code_1                =    SINGLE_ONE;
    uint8_t          session_code_0                =    SINGLE_ZERO;
    uint8_t          loop_sram                     =    0;

    switch(m_query_rep_session)
    {
        case SESSION_S0:    session_code_1    =    SINGLE_ZERO; session_code_0    =    SINGLE_ZERO; break;
        case SESSION_S1:    session_code_1    =    SINGLE_ZERO; session_code_0    =    SINGLE_ONE; break;
        case SESSION_S2:    session_code_1    =    SINGLE_ONE; session_code_0     =    SINGLE_ZERO; break;
        case SESSION_S3:    session_code_1    =    SINGLE_ONE; session_code_0     =    SINGLE_ONE; break;
        default:            session_code_1    =    SINGLE_ONE; session_code_0     =    SINGLE_ZERO; break;
    }

    //Write opcodes to TX RAM, converting bits to opcodes where necessary
    radio_sram_addr       =    TX_RAM_ADDR_OFFSET_QRY_REP << 4;
    error_code            =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_IMMED,radio_sram_addr++);       if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code            =    merge_and_write_tx_ram(SINGLE_ZERO,RTCAL,radio_sram_addr++);            if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code            =    merge_and_write_tx_ram(session_code_1,SINGLE_ZERO,radio_sram_addr++);   if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code            =    merge_and_write_tx_ram(END_PACKET,session_code_0,radio_sram_addr++);    if(error_code != RFIDR_SUCCESS){return error_code;}
    
    
    for(loop_sram=0; loop_sram < 3; loop_sram++)
    {
        //Overwrite data that could be overwritten by QueryAdjust with the opcode that translates to 4'b0000.
        error_code        =    merge_and_write_tx_ram(TXCW0,TXCW0,radio_sram_addr++);                  if(error_code != RFIDR_SUCCESS){return error_code;}
    }

    return RFIDR_SUCCESS;
}

//Bitwise-construct a Query Adjust command and load it into the TX RAM .
//In this case we need to draw upon the session state variable 
//(another good reason to make this a state variable - so that we can issue Query, Query Rep and Query Adjust TX RAM writes easily with only one setting of the session).

rfidr_error_t load_query_adj_packet(bool up_downb)
{
    uint16_t         radio_sram_addr              =    0;
    rfidr_error_t    error_code                   =    0;
    uint8_t          session_code_1               =    SINGLE_ONE;
    uint8_t          session_code_0               =    SINGLE_ZERO;
    uint8_t          updown_code_2                =    SINGLE_ONE;
    uint8_t          updown_code_1                =    SINGLE_ONE;
    uint8_t          updown_code_0                =    SINGLE_ZERO;

    switch(m_query_rep_session)
    {
        case SESSION_S0:    session_code_1    =    SINGLE_ZERO; session_code_0   =    SINGLE_ZERO; break;
        case SESSION_S1:    session_code_1    =    SINGLE_ZERO; session_code_0   =    SINGLE_ONE; break;
        case SESSION_S2:    session_code_1    =    SINGLE_ONE; session_code_0    =    SINGLE_ZERO; break;
        case SESSION_S3:    session_code_1    =    SINGLE_ONE; session_code_0    =    SINGLE_ONE; break;
        default:            session_code_1    =    SINGLE_ONE; session_code_0    =    SINGLE_ZERO; break;
    }
    
    if(up_downb)
    {
        updown_code_2    =    updown_code_1    =    SINGLE_ONE; updown_code_0    =    SINGLE_ZERO;
    }
    else
    {
        updown_code_2    =    SINGLE_ZERO; updown_code_1    =    updown_code_0    =    SINGLE_ONE;
    }

    //Load Query Adjust into the same RAM slot at Query Rep.
    //The idea is that sometime in the middle of inventory when control is passed back from the FPGA to the MCU that
    //the Query Adjust packet is swapped in for the Query Rep packet.
    //Then after the next pass of control back to the MCU, the regular Query Rep packet will be loaded into this RAM slot.
    //This is just for demonstration purposes - it's difficult to envision at the moment when QueryAdjust would be advantageously used.
    
    //Write opcodes to TX RAM, converting bits to opcodes where necessary
    radio_sram_addr     =    TX_RAM_ADDR_OFFSET_QRY_REP << 4;
    error_code          =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_IMMED,radio_sram_addr++);            if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ONE,RTCAL,radio_sram_addr++);                  if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ZERO,radio_sram_addr++);           if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(session_code_1,SINGLE_ONE,radio_sram_addr++);         if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(updown_code_2,session_code_0,radio_sram_addr++);      if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(updown_code_0,updown_code_1,radio_sram_addr++);       if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(TXCW0,END_PACKET,radio_sram_addr++);                  if(error_code != RFIDR_SUCCESS){return error_code;}
    
    return RFIDR_SUCCESS;

}


//Bitwise-construct an ACK (with Handle) command and load it into the TX RAM.
static rfidr_error_t load_ack_handle_packet(void)
{
    uint16_t         radio_sram_addr               =    0;
    rfidr_error_t    error_code                    =    0;

    radio_sram_addr    =    TX_RAM_ADDR_OFFSET_ACK_HDL << 4;
    error_code         =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_IMMED,radio_sram_addr++);           if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code         =    merge_and_write_tx_ram(SINGLE_ZERO,RTCAL,radio_sram_addr++);                if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code         =    merge_and_write_tx_ram(INSERT_HANDLE,SINGLE_ONE,radio_sram_addr++);         if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code         =    merge_and_write_tx_ram(TXCW0,END_PACKET,radio_sram_addr++);                 if(error_code != RFIDR_SUCCESS){return error_code;}

    return RFIDR_SUCCESS;
}

//Bitwise-construct an ACK (with RN16) command and load it into the TX RAM.
static rfidr_error_t load_ack_rn16_packet(void)
{
    uint16_t         radio_sram_addr              =    0;
    rfidr_error_t    error_code                   =    RFIDR_SUCCESS;

    radio_sram_addr     =    TX_RAM_ADDR_OFFSET_ACK_RN16 << 4;
    error_code          =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_IMMED,radio_sram_addr++);          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,RTCAL,radio_sram_addr++);               if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(INSERT_RN16,SINGLE_ONE,radio_sram_addr++);          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(TXCW0,END_PACKET,radio_sram_addr++);                if(error_code != RFIDR_SUCCESS){return error_code;}

    return RFIDR_SUCCESS;
}

//Bitwise-construct a NAK command and load it into the TX RAM.
static rfidr_error_t load_nak_packet(void)
{
    uint16_t         radio_sram_addr               =    0;
    rfidr_error_t    error_code                    =    RFIDR_SUCCESS;

    radio_sram_addr     =    TX_RAM_ADDR_OFFSET_NAK << 4;
    error_code          =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_IMMED,radio_sram_addr++);          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ONE,RTCAL,radio_sram_addr++);                if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ONE,radio_sram_addr++);          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ZERO,radio_sram_addr++);         if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ZERO,radio_sram_addr++);         if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(NAK_END,SINGLE_ZERO,radio_sram_addr++);             if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(TXCW0,END_PACKET,radio_sram_addr++);                if(error_code != RFIDR_SUCCESS){return error_code;}

    return    RFIDR_SUCCESS;
}

//Bitwise-construct a Request Handle command and load it into the TX RAM.
static rfidr_error_t load_reqhdl_packet(void)
{
    uint16_t         radio_sram_addr               =    0;
    rfidr_error_t    error_code                    =    RFIDR_SUCCESS;

    radio_sram_addr     =    TX_RAM_ADDR_OFFSET_REQHDL << 4;
    error_code          =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_IMMED,radio_sram_addr++);          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ONE,RTCAL,radio_sram_addr++);                if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ONE,radio_sram_addr++);          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ZERO,radio_sram_addr++);         if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ZERO,radio_sram_addr++);         if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(INSERT_RN16,SINGLE_ONE,radio_sram_addr++);          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(END_PACKET,INSERT_CRC16,radio_sram_addr++);         if(error_code != RFIDR_SUCCESS){return error_code;}

    return RFIDR_SUCCESS;
}

//Bitwise-construct a Request RN16 command and load it into the TX RAM.
static rfidr_error_t load_reqrn16_packet(void)
{
    uint16_t         radio_sram_addr               =    TX_RAM_ADDR_OFFSET_REQRN16 << 4;;
    rfidr_error_t    error_code                    =    RFIDR_SUCCESS;

    error_code          =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_IMMED,radio_sram_addr++);           if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ONE,RTCAL,radio_sram_addr++);                 if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ONE,radio_sram_addr++);           if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ZERO,radio_sram_addr++);          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(SINGLE_ZERO,SINGLE_ZERO,radio_sram_addr++);          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(INSERT_HANDLE,SINGLE_ONE,radio_sram_addr++);         if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code          =    merge_and_write_tx_ram(END_PACKET,INSERT_CRC16,radio_sram_addr++);          if(error_code != RFIDR_SUCCESS){return error_code;}

    return RFIDR_SUCCESS;
}

//Bitwise-construct a LOCK command and load it into the TX RAM.
static rfidr_error_t load_lock_packet(void)
{
    //For now, write zeros in the lock packet. Later during testing, we will try locking epc memory

    uint32_t         lock_vector                  =    0;
    uint8_t          loop_sram                    =    0;
    uint16_t         radio_sram_addr              =    0;
    uint8_t          shift_msb                    =    0;
    uint8_t          shift_lsb                    =    0;
    rfidr_error_t    error_code                   =    RFIDR_SUCCESS;

    //Build the components of a lock command into a 28-bit bit string

    lock_vector |= ((197 & 255) << 20);    //Command 11000101
    lock_vector |= ((32 & 1023) << 10);    //Don't do anything for the time being. Use 32 for temp. lock of epc.
    lock_vector |= ((0 & 1023) << 0);      //Don't do anything for the time being. Use 32 for temp. lock of epc, 0 to unlock.

    //Write opcodes to TX RAM, converting 1's and 0's to opcodes where necessary.
    radio_sram_addr       =    TX_RAM_ADDR_OFFSET_LOCK << 4;
    error_code            =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_REGULAR,radio_sram_addr++);                                      if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code            =    merge_and_write_tx_ram(((lock_vector >> 27) & 1) ? SINGLE_ONE : SINGLE_ZERO,RTCAL,radio_sram_addr++);    if(error_code != RFIDR_SUCCESS){return error_code;}

    for(loop_sram=0;loop_sram < 13;loop_sram++)
    {
        shift_msb            =    25-(loop_sram<<1);
        shift_lsb            =    26-(loop_sram<<1);

        error_code           =    merge_and_write_tx_ram(((lock_vector >> shift_msb) & 1) ? SINGLE_ONE : SINGLE_ZERO,((lock_vector >> shift_lsb) & 1) ? SINGLE_ONE : SINGLE_ZERO,radio_sram_addr++);
        if(error_code != RFIDR_SUCCESS){return error_code;}
    }

    error_code            =    merge_and_write_tx_ram(INSERT_HANDLE,((lock_vector >> 0) & 1) ? SINGLE_ONE : SINGLE_ZERO,radio_sram_addr++);    if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code            =    merge_and_write_tx_ram(END_PACKET,INSERT_CRC16,radio_sram_addr++);                                              if(error_code != RFIDR_SUCCESS){return error_code;}

    return RFIDR_SUCCESS;
}

//Bitwise-construct a READ command and load it into the TX RAM.
//We use this to read back the EPC to confirm that we programmed the correct one in.
static rfidr_error_t load_read_packet(void)
{
    uint32_t        read_vector                  =    0;
    uint8_t         loop_sram                    =    0;
    uint16_t        radio_sram_addr              =    0;
    uint8_t         shift_msb                    =    0;
    uint8_t          shift_lsb                   =    0;
    rfidr_error_t    error_code                  =    RFIDR_SUCCESS;

    //Build the components of a read command into a 24-bit bit string

    read_vector |= ((194 & 255) << 18);    //Command 11000010.
    read_vector |= ((1 & 3) << 16);        //Strictly target EPC memory bank.
    read_vector |= ((2 & 255) << 8);       //Strictly target EPC word pointer #2
    read_vector |= ((6 & 255) << 0);       //Read 6 16-bit words (96 bit epc).

    //Write opcodes to TX RAM, converting 1's and 0's to opcodes where necessary.
    radio_sram_addr       =    TX_RAM_ADDR_OFFSET_READ << 4;
    error_code            =    merge_and_write_tx_ram(DUMMY_ZERO,BEGIN_REGULAR,radio_sram_addr++);                                      if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code            =    merge_and_write_tx_ram(((read_vector >> 25) & 1) ? SINGLE_ONE : SINGLE_ZERO,RTCAL,radio_sram_addr++);    if(error_code != RFIDR_SUCCESS){return error_code;}

    for(loop_sram=0;loop_sram < 12;loop_sram++)
    {
        shift_msb         =    23-(loop_sram<<1);
        shift_lsb         =    24-(loop_sram<<1);

        error_code        =    merge_and_write_tx_ram(((read_vector >> shift_msb) & 1) ? SINGLE_ONE : SINGLE_ZERO,((read_vector >> shift_lsb) & 1) ? SINGLE_ONE : SINGLE_ZERO,radio_sram_addr++);
        if(error_code != RFIDR_SUCCESS){return error_code;}
    }

    error_code            =    merge_and_write_tx_ram(INSERT_HANDLE,((read_vector >> 0) & 1) ? SINGLE_ONE : SINGLE_ZERO,radio_sram_addr++);    if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code            =    merge_and_write_tx_ram(END_PACKET,INSERT_CRC16,radio_sram_addr++);    if(error_code != RFIDR_SUCCESS){return error_code;}

    return RFIDR_SUCCESS;
}

//Quickly load up the FPGA TX RAM with a set of default commands so that if
//firmware does something unexpected, at least the TX section of the FPGA is
//configured to operate in a valid fashion. 
rfidr_error_t    load_rfidr_txram_default(void)
{
    rfidr_error_t    error_code        =    NRF_SUCCESS;

    error_code=load_txcw0_packet();                                                          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_select_packet_only(ZERO_EPC,MAX_EPC_LENGTH_IN_BYTES,SEL_PACKET_NO_1);    if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_select_packet_only(ZERO_EPC,MAX_EPC_LENGTH_IN_BYTES,SEL_PACKET_NO_2);    if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_query_packet_only(FLAGSWAP_NO);                                          if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_query_rep_packet();                                                      if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_ack_handle_packet();                                                     if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_ack_rn16_packet();                                                       if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_nak_packet();                                                            if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_reqhdl_packet();                                                         if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_reqrn16_packet();                                                        if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_write_packet_only_program_epc();                                         if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_read_packet();                                                           if(error_code != RFIDR_SUCCESS){return error_code;}
    error_code=load_lock_packet();                                                           if(error_code != RFIDR_SUCCESS){return error_code;}
    
    return RFIDR_SUCCESS;
}
